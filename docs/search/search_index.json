{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"msmu","text":"<p>Python toolkit for LC-MS/MS Proteomics analysis based on MuData</p>"},{"location":"#overview","title":"Overview","text":"<p><code>msmu</code> is a Python package for scalable, modular, and reproducible LC-MS/MS <code>proteomics</code> data analysis. It supports PSM, peptide, and protein-level processing, integrates <code>MuData</code> (AnnData) structure, and enables stepwise normalization, batch correction, and statistical testing for biomarker discovery and systems biology.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible data ingestion from DIA-NN, Sage (now supporting), and other Database search tools (future)</li> <li>MuData/AnnData-compatible object structure for multi-level omics</li> <li>Built-in QC: precursor purity, peptide length, charge, missed cleavage</li> <li>Protein inference: infer protein with ... rule</li> <li>Normalization options: log2, quantile, median centering, GIS/IRS</li> <li>Statistical analysis: permutation-based DE test and FDR</li> <li>PTM support and stoichiometry adjustment with global dataset</li> <li>Visualization: PCA, UMAP, volcano plots, heatmaps, QC metrics</li> </ul>"},{"location":"#file-structure-and-input-format","title":"File Structure and Input Format","text":""},{"location":"#accepted-inputs","title":"Accepted inputs","text":"<ul> <li>Sage: folder with PSM tables</li> <li>DIA-NN: output folder</li> <li>MaxQuant</li> <li>FragPipe (MSFragger)</li> <li>DelPy</li> </ul>"},{"location":"#output","title":"Output","text":"<ul> <li>Integrated multi-level MuData object (<code>.h5mu</code>)</li> <li>Summary plots and statistics</li> <li>Differentially expressed proteins/sites with FDR</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>UPCOMING - \u2705 Support DIA-NN and Sage formats - \u2705 Normalize and aggregate pipeline - \u2705 QC metric visualization - \u2705 PTM stoichiometry inference</p>"},{"location":"#citation","title":"Citation","text":"<p>UPCOMING If you use msmu in your work, please cite:</p> <p>Choi and Lee et al., msmu: A Pythonic Framework for Modular Proteomics Analysis, in prep.</p>"},{"location":"#license","title":"License","text":"<p>UPCOMING MIT License. See LICENSE for details.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>\ube60\ub978 \uc2dc\uc791</li> <li>API \ub808\ud37c\ub7f0\uc2a4</li> <li>\uc608\uc81c \ub178\ud2b8\ubd81</li> </ul>"},{"location":"installation/","title":"INSTALLATION","text":""},{"location":"installation/#from-pip","title":"from PIP","text":"<pre><code>pip install msmu\n</code></pre>"},{"location":"installation/#from-source","title":"from Source","text":"<pre><code>git clone git@bitbucket.org:bertis/msmu.git\n</code></pre>"},{"location":"reference/","title":"msmu","text":""},{"location":"reference/_version/","title":"<code>msmu._version</code>","text":""},{"location":"reference/logging_utils/","title":"<code>msmu.logging_utils</code>","text":""},{"location":"reference/msmu/","title":"<code>msmu.msmu</code>","text":""},{"location":"reference/_plotting/","title":"_plotting","text":""},{"location":"reference/_plotting/__pdata/","title":"<code>msmu._plotting.__pdata</code>","text":""},{"location":"reference/_plotting/__ptypes/","title":"<code>msmu._plotting.__ptypes</code>","text":""},{"location":"reference/_plotting/__trace/","title":"<code>msmu._plotting.__trace</code>","text":""},{"location":"reference/_plotting/_template/","title":"<code>msmu._plotting._template</code>","text":""},{"location":"reference/_plotting/_utils/","title":"<code>msmu._plotting._utils</code>","text":""},{"location":"reference/_plotting/plots/","title":"<code>msmu._plotting.plots</code>","text":""},{"location":"reference/_preprocessing/","title":"_preprocessing","text":""},{"location":"reference/_preprocessing/_compute_precursor_purity/","title":"<code>msmu._preprocessing._compute_precursor_purity</code>","text":""},{"location":"reference/_preprocessing/_compute_precursor_purity/#msmu._preprocessing._compute_precursor_purity.compute_precursor_purity","title":"compute_precursor_purity","text":"<pre><code>compute_precursor_purity(mdata, mzml_paths, tolerance=20.0, unit_ppm=True)\n</code></pre> <p>Calculate precursor isolation purity for PSMs in the given MuData object and mzML file.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing PSM data.</p> required <code>mzml_paths</code> <code>str | Path | list</code> <p>Full path(s) to the mzML file.</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for precursor purity calculation. Default is 20.</p> <code>20.0</code> <code>unit_ppm</code> <code>bool</code> <p>Whether to use ppm for tolerance. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: MuData object containing purity results.</p>"},{"location":"reference/_preprocessing/_filter/","title":"<code>msmu._preprocessing._filter</code>","text":""},{"location":"reference/_preprocessing/_filter/#msmu._preprocessing._filter.add_filter","title":"add_filter","text":"<pre><code>add_filter(mdata, modality, column, keep, value)\n</code></pre> <p>Adds a filter to the specified modality in the MuData object based on the given condition.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to which the filter will be added.</p> required <code>modality</code> <code>str</code> <p>The modality within the MuData object to which the filter will be applied</p> required <code>column</code> <code>str</code> <p>The column in the modality's var DataFrame to apply the filter on.</p> required <code>value</code> <code>str | float | None</code> <p>The value to compare against for filtering.</p> required <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>MuData object with the added filter.</p>"},{"location":"reference/_preprocessing/_filter/#msmu._preprocessing._filter.apply_filter","title":"apply_filter","text":"<pre><code>apply_filter(mdata, modality)\n</code></pre> <p>Applies the filter to the specified modality in the MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to which the filter will be applied.</p> required <code>modality</code> <code>str</code> <p>The modality within the MuData object to which the filter will be applied.</p> required <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>MuData object with the filter applied.</p>"},{"location":"reference/_preprocessing/_infer_protein/","title":"<code>msmu._preprocessing._infer_protein</code>","text":""},{"location":"reference/_preprocessing/_infer_protein/#msmu._preprocessing._infer_protein.get_protein_mapping","title":"get_protein_mapping","text":"<pre><code>get_protein_mapping(peptides, proteins)\n</code></pre> <p>Infer protein grouping information.</p> <p>Parameters:</p> Name Type Description Default <code>peptides</code> <code>Series</code> <p>peptide information</p> required <code>proteins</code> <code>Series</code> <p>protein information</p> required <p>Returns:</p> Name Type Description <code>peptide_map</code> <code>DataFrame</code> <p>peptide mapping information</p> <code>protein_map</code> <code>DataFrame</code> <p>protein mapping information</p> <code>protein_info</code> <code>DataFrame</code> <p>protein information</p>"},{"location":"reference/_preprocessing/_infer_protein/#msmu._preprocessing._infer_protein.infer_protein","title":"infer_protein","text":"<pre><code>infer_protein(mdata, propagated_from=None)\n</code></pre> <p>Infer protein grouping information and classify peptides.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object</p> required <code>propagated_from</code> <code>MuData | str | None</code> <p>mudata which contains inference info (for PTM normalisation with global proteins). Can be path to global data .h5mu or mudata object. Default is None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>MuData object with updated protein mappings</p>"},{"location":"reference/_preprocessing/_infer_protein/#msmu._preprocessing._infer_protein.select_canon_prot","title":"select_canon_prot","text":"<pre><code>select_canon_prot(protein_group, protein_info)\n</code></pre> <p>DEPRECATED: Use <code>select_representative</code> instead.</p> <p>Select canonical protein from protein list based on priority. canonical &gt; swissprot &gt; trembl &gt; contam</p> <p>Parameters:</p> Name Type Description Default <code>protein_group</code> <code>str</code> <p>protein group (uniprot entry)</p> required <p>Returns:</p> Name Type Description <code>protein_group</code> <code>str</code> <p>canonical protein group</p>"},{"location":"reference/_preprocessing/_infer_protein/#msmu._preprocessing._infer_protein.select_representative","title":"select_representative","text":"<pre><code>select_representative(protein_group, protein_info)\n</code></pre> <p>Select canonical protein from protein list based on priority. canonical &gt; swissprot &gt; trembl &gt; contam</p> <p>Parameters:</p> Name Type Description Default <code>protein_list</code> <code>list[str]</code> <p>list of proteins (uniprot entry)</p> required <code>protein_info</code> <code>DataFrame</code> <p>DataFrame of protein info from mdata.uns['protein_info']</p> required <p>Returns:</p> Name Type Description <code>protein_group</code> <code>str</code> <p>canonical protein group</p>"},{"location":"reference/_preprocessing/_infer_protein_deprecated/","title":"<code>msmu._preprocessing._infer_protein_deprecated</code>","text":""},{"location":"reference/_preprocessing/_normalise/","title":"_normalise","text":""},{"location":"reference/_preprocessing/_normalise/_normalise/","title":"<code>msmu._preprocessing._normalise._normalise</code>","text":""},{"location":"reference/_preprocessing/_normalise/_normalise/#msmu._preprocessing._normalise._normalise.adjust_ptm_by_protein","title":"adjust_ptm_by_protein","text":"<pre><code>adjust_ptm_by_protein(mdata, global_mdata, ptm_mod='phospho_site', method='ridge', rescale=True)\n</code></pre> <p>Estimation of PTM stoichiometry by using Global Protein Data.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to normalise.</p> required <code>global_mdata</code> <code>MuData</code> <p>MuData object which contains global protein expression.</p> required <code>ptm_mod</code> <code>str</code> <p>PTM modality to normalise (e.g. phospho_site, {ptm}_site).</p> <code>'phospho_site'</code> <code>global_mod</code> <code>str</code> <p>Modality in global_mdata to normalise PTM site. Default is 'protein'.</p> required <code>method</code> <code>str</code> <p>A method for normalisation. Options: ridge, ratio. Default is 'ridge'.</p> <code>'ridge'</code> <code>rescale</code> <code>bool</code> <p>If True, rescale the data after normalisation with median value across dataset. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>Normalised MuData object.</p>"},{"location":"reference/_preprocessing/_normalise/_normalise/#msmu._preprocessing._normalise._normalise.feature_scale","title":"feature_scale","text":"<pre><code>feature_scale(mdata, method, modality, gis_prefix=None, gis_col=None, rescale=True)\n</code></pre> <p>Feature scale data in MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to normalise.</p> required <code>method</code> <code>str</code> <p>Normalisation method to use. Options are 'gis', 'median_center'.</p> required <code>modality</code> <code>str</code> <p>Modality to normalise.</p> required <code>gis_prefix</code> <code>str | None</code> <p>Prefix for GIS samples. If None, all samples with 'gis' in the name will be used.</p> <code>None</code> <code>gis_col</code> <code>list[str] | None</code> <p>Column name for GIS samples. If None, all samples with 'gis' in the name will be used.</p> <code>None</code> <code>rescale</code> <code>bool</code> <p>If True, rescale the data after normalisation with median value across dataset. This is only applicable for median normalisation.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>Normalised MuData object.</p>"},{"location":"reference/_preprocessing/_normalise/_normalise/#msmu._preprocessing._normalise._normalise.get_modality_dict","title":"get_modality_dict","text":"<pre><code>get_modality_dict(mdata, level=None, modality=None)\n</code></pre> <p>Get modality data from MuData object</p>"},{"location":"reference/_preprocessing/_normalise/_normalise/#msmu._preprocessing._normalise._normalise.normalise","title":"normalise","text":"<pre><code>normalise(mdata, method, modality, fraction=False, rescale=True)\n</code></pre> <p>Normalise data in MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to normalise.</p> required <code>method</code> <code>str</code> <p>Normalisation method to use. Options are 'quantile', 'median', 'total_sum (not implemented)'.</p> required <code>modality</code> <code>str</code> <p>Modality to normalise. If None, all modalities at the specified level will be normalised.</p> required <code>fraction</code> <code>bool</code> <p>If True, normalise within fractions. If False, normalise across all data. \"fraction\" yet supports fractionated TMT.</p> <code>False</code> <code>rescale</code> <code>bool</code> <p>If True, rescale the data after normalisation with median value across dataset. This is only applicable for median normalisation.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>Normalised MuData object.</p>"},{"location":"reference/_preprocessing/_normalise/normalisation_methods/","title":"<code>msmu._preprocessing._normalise.normalisation_methods</code>","text":""},{"location":"reference/_preprocessing/_normalise/normalisation_methods/#msmu._preprocessing._normalise.normalisation_methods.normalise_median_center","title":"normalise_median_center","text":"<pre><code>normalise_median_center(arr)\n</code></pre> <p>Median centering of data</p>"},{"location":"reference/_preprocessing/_normalise/normalisation_methods/#msmu._preprocessing._normalise.normalisation_methods.normalise_total_sum","title":"normalise_total_sum","text":"<pre><code>normalise_total_sum()\n</code></pre> <p>Total sum normalisation of data</p>"},{"location":"reference/_preprocessing/_summarise/","title":"_summarise","text":""},{"location":"reference/_preprocessing/_summarise/_summarise/","title":"<code>msmu._preprocessing._summarise._summarise</code>","text":""},{"location":"reference/_preprocessing/_summarise/_summarise/#msmu._preprocessing._summarise._summarise.to_peptide","title":"to_peptide","text":"<pre><code>to_peptide(mdata, agg_method='median', calculate_q=True, score_method='best_pep', purity_threshold=0.7, top_n=None, rank_method='total_intensity', _peptide_col='peptide', _protein_col='proteins')\n</code></pre> <p>Summarise feature-level data to peptide-level data.</p> Usage <p>mdata = mm.pp.to_peptide(     mdata,     agg_method=\"median\",     calculate_q=True,     score_method=\"best_pep\",     purity_threshold=0.7, )</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing feature-level data.</p> required <code>agg_method</code> <code>Literal['median', 'mean', 'sum']</code> <p>Aggregation method for quantification to use. Defaults to \"median\".</p> <code>'median'</code> <code>calculate_q</code> <code>bool</code> <p>Whether to calculate q-values. Defaults to True.</p> <code>True</code> <code>score_method</code> <code>Literal['best_pep']</code> <p>Method to combine scores. Defaults to \"best_pep\".</p> <code>'best_pep'</code> <code>purity_threshold</code> <code>float | None</code> <p>Purity threshold for TMT data quantification aggregation (does not filter out features). If None, no filtering is applied. Defaults to 0.7.</p> <code>0.7</code> <code>top_n</code> <code>int | None</code> <p>Number of top features to consider for summarisation. If None, all features are used. Defaults to None.</p> <code>None</code> <code>rank_method</code> <code>Literal['total_intensity', 'max_intensity', 'median_intensity']</code> <p>Method to rank features when selecting top_n. Defaults to \"total_intensity\".</p> <code>'total_intensity'</code> <code>_peptide_col</code> <code>str</code> <p>Column name for peptides in var DataFrame. Defaults to \"peptide\".</p> <code>'peptide'</code> <code>_protein_col</code> <code>str</code> <p>Column name for proteins in var DataFrame. Defaults to \"proteins\".</p> <code>'proteins'</code> <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>MuData object containing peptide-level data.</p>"},{"location":"reference/_preprocessing/_summarise/_summarise/#msmu._preprocessing._summarise._summarise.to_protein","title":"to_protein","text":"<pre><code>to_protein(mdata, agg_method='median', calculate_q=True, score_method='best_pep', top_n=3, rank_method='total_intensity', _protein_col='protein_group', _shared_peptide='discard')\n</code></pre> <p>Summarise feature-level data to protein-level data. By default, uses <code>top 3</code> peptides in their <code>total_intensity</code> and <code>unique</code> (_shared_peptide = \"discard\") per protein_group for quantification aggregation with median.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing feature-level data.</p> required <code>agg_method</code> <code>Literal['median', 'mean', 'sum']</code> <p>Aggregation method to use. Defaults to \"median\".</p> <code>'median'</code> <code>calculate_q</code> <code>bool</code> <p>Whether to calculate q-values. Defaults to True.</p> <code>True</code> <code>score_method</code> <code>Literal['best_pep']</code> <p>Method to combine scores (PEP). Defaults to \"best_pep\".</p> <code>'best_pep'</code> <code>top_n</code> <code>int | None</code> <p>Number of top peptides to consider for summarisation. If None, all peptides are used. Defaults to None.</p> <code>3</code> <code>rank_method</code> <code>Literal['total_intensity', 'max_intensity', 'median_intensity']</code> <p>Method to rank features when selecting top_n. Defaults to \"total_intensity\".</p> <code>'total_intensity'</code> <code>_protein_col</code> <code>str</code> <p>Column name for proteins in var DataFrame. Defaults to \"protein_group\".</p> <code>'protein_group'</code> <code>_shared_peptide</code> <code>Literal['discard']</code> <p>How to handle shared peptides. Currently only \"discard\" is implemented. Defaults to \"discard\".</p> <code>'discard'</code> <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>MuData object containing protein-level data.</p>"},{"location":"reference/_preprocessing/_summarise/_summarise/#msmu._preprocessing._summarise._summarise.to_ptm","title":"to_ptm","text":"<pre><code>to_ptm(mdata, modi_name, modification, agg_method='median', top_n=None, rank_method='total_intensity')\n</code></pre> <p>Summarise feature-level data to PTM-level data.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing peptide-level data.</p> required <code>modi_name</code> <code>str</code> <p>Name of the PTM to summarise (e.g., \"phospho\"). Will be used in the output modality name (eg. phospho_site).</p> required <code>modification</code> <code>str</code> <p>Modification string (e.g., \"[+79.96633]\", \"(unimod:21)\").</p> required <code>agg_method</code> <code>Literal['median', 'mean', 'sum']</code> <p>Aggregation method to use. Defaults to \"median\".</p> <code>'median'</code> <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>MuData object containing PTM-level data.</p>"},{"location":"reference/_preprocessing/_summarise/_summarise_deprecated/","title":"<code>msmu._preprocessing._summarise._summarise_deprecated</code>","text":""},{"location":"reference/_preprocessing/_summarise/_summariser/","title":"<code>msmu._preprocessing._summarise._summariser</code>","text":""},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Aggregator","title":"Aggregator","text":"<pre><code>Aggregator(identification_df, quantification_df, decoy_df, agg_method, score_method)\n</code></pre> <p>Base class for aggregating identification and quantification data.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Aggregator.peptide","title":"peptide  <code>classmethod</code>","text":"<pre><code>peptide(identification_df, quantification_df, decoy_df, agg_method, score_method, protein_col, peptide_col)\n</code></pre> <p>Create a peptide-level aggregator.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Aggregator.protein","title":"protein  <code>classmethod</code>","text":"<pre><code>protein(identification_df, quantification_df, decoy_df, agg_method, score_method, protein_col)\n</code></pre> <p>Create a protein-level aggregator.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Aggregator.ptm_site","title":"ptm_site  <code>classmethod</code>","text":"<pre><code>ptm_site(identification_df, quantification_df, agg_method)\n</code></pre> <p>Create a PTM site-level aggregator.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.FeatureRanker","title":"FeatureRanker","text":"<p>Ranking methods for selecting top features based on quantification data.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.FeatureRanker.max_intensity","title":"max_intensity  <code>staticmethod</code>","text":"<pre><code>max_intensity(identification_df, quantification_df, col_to_groupby)\n</code></pre> <p>Rank features based on maximum intensity across all samples.</p> <p>Parameters:</p> Name Type Description Default <code>identification_df</code> <code>DataFrame</code> <p>DataFrame containing feature identifications.</p> required <code>quantification_df</code> <code>DataFrame</code> <p>DataFrame containing feature quantifications.</p> required <code>col_to_groupby</code> <code>str</code> <p>Column name to group by for ranking.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame with added 'rank_score' and 'rank' columns.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.FeatureRanker.median_intensity","title":"median_intensity  <code>staticmethod</code>","text":"<pre><code>median_intensity(identification_df, quantification_df, col_to_groupby)\n</code></pre> <p>Rank features based on median intensity across all samples.</p> <p>Parameters:</p> Name Type Description Default <code>identification_df</code> <code>DataFrame</code> <p>DataFrame containing feature identifications.</p> required <code>quantification_df</code> <code>DataFrame</code> <p>DataFrame containing feature quantifications.</p> required <code>col_to_groupby</code> <code>str</code> <p>Column name to group by for ranking.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame with added 'rank_score' and 'rank' columns.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.FeatureRanker.total_intensity","title":"total_intensity  <code>staticmethod</code>","text":"<pre><code>total_intensity(identification_df, quantification_df, col_to_groupby)\n</code></pre> <p>Rank features based on total intensity across all samples.</p> <p>Parameters:</p> Name Type Description Default <code>identification_df</code> <code>DataFrame</code> <p>DataFrame containing feature identifications.</p> required <code>quantification_df</code> <code>DataFrame</code> <p>DataFrame containing feature quantifications.</p> required <code>col_to_groupby</code> <code>str</code> <p>Column name to group by for ranking.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: DataFrame with added 'rank_score' and 'rank' columns.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.PtmSummarisationPrep","title":"PtmSummarisationPrep","text":"<pre><code>PtmSummarisationPrep(adata, modi_identifier, fasta)\n</code></pre> <p>               Bases: <code>SummarisationPrep</code></p> <p>Preparation steps for PTM site summarisation.     1. Filter data with only modified peptides with modi_identifier     2. Get modified sites from peptide     3. Label peptide site     4. Explode data to single protein for labeling protein site     5. Label protein site to each single protein     6. Wrap up single protein to single protein group     7. Group by modified peptide and its peptide site     8. Merge data with peptide value indexed by peptide</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.PtmSummarisationPrep.label_ptm_site","title":"label_ptm_site","text":"<pre><code>label_ptm_site(data)\n</code></pre> <p>Label PTM site to each single protein and get data arranged by peptide - peptide site</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>Peptide data from msmu mudata['peptide']</p> required <p>Returns:</p> Name Type Description <code>ptm_data</code> <code>DataFrame</code> <p>PTM data arranged by peptide - peptide site</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Scorer","title":"Scorer","text":"<pre><code>Scorer(pep)\n</code></pre> <p>Scoring methods for aggregating PSM scores to peptide/protein scores.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Scorer.picked_pep","title":"picked_pep  <code>property</code>","text":"<pre><code>picked_pep\n</code></pre> <p>The aggregated PEP value.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Scorer.picked_score","title":"picked_score  <code>property</code>","text":"<pre><code>picked_score\n</code></pre> <p>The \u2212log10 transformed score.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Scorer.best_pep","title":"best_pep  <code>classmethod</code>","text":"<pre><code>best_pep(values)\n</code></pre> <p>Factory for best PEP aggregation.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.Scorer.func","title":"func  <code>classmethod</code>","text":"<pre><code>func(method)\n</code></pre> <p>Return a pure function that returns numeric PEPs (for pandas .agg).</p>"},{"location":"reference/_preprocessing/_summarise/_summariser/#msmu._preprocessing._summarise._summariser.SummarisationPrep","title":"SummarisationPrep","text":"<pre><code>SummarisationPrep(adata, col_to_groupby, has_decoy)\n</code></pre> <p>Preparation steps for summarisation.</p> <p>Attributes:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>MuData object containing feature-level data.</p> <code>filter_dict</code> <code>dict</code> <p>Dictionary specifying filtering criteria.</p> <code>rank_dict</code> <code>dict</code> <p>Dictionary specifying ranking criteria.</p>"},{"location":"reference/_preprocessing/_summarise/_summariser_deprecated/","title":"<code>msmu._preprocessing._summarise._summariser_deprecated</code>","text":""},{"location":"reference/_read_write/","title":"_read_write","text":""},{"location":"reference/_read_write/_base_reader/","title":"<code>msmu._read_write._base_reader</code>","text":""},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.MuDataInput","title":"MuDataInput  <code>dataclass</code>","text":"<pre><code>MuDataInput(raw_feature_df, norm_feature_df, norm_quant_df, search_config, decoy_df)\n</code></pre> <p>Dataclass to store inputs for creating a MuData object.</p> <p>Attributes:</p> Name Type Description <code>raw_feature_df</code> <code>DataFrame</code> <p>Raw feature DataFrame (varm['search_result']).</p> <code>norm_feature_df</code> <code>DataFrame</code> <p>Normalized feature DataFrame.</p> <code>norm_quant_df</code> <code>DataFrame</code> <p>Normalized quantification DataFrame.</p> <code>search_result</code> <code>DataFrame</code> <p>Original search result DataFrame.</p> <code>search_config</code> <code>dict</code> <p>Configuration settings from the search engine.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultReader","title":"SearchResultReader","text":"<pre><code>SearchResultReader()\n</code></pre> <p>Base class for reading and processing search engine results.</p> <p>Attributes:</p> Name Type Description <code>search_settings</code> <code>SearchResultSettings</code> <p>Settings for the search results.</p> <code>used_feature_cols</code> <code>list[str]</code> <p>List of columns to be used in the feature DataFrame.</p> <code>base_level</code> <code>Literal['psm', 'precursor'] | None</code> <p>Base level of the data (e.g., \"psm\" or \"precursor\").</p> <code>_feature_rename_dict</code> <code>dict</code> <p>Dictionary for renaming feature columns.</p> <p>Methods:</p> Name Description <code>read</code> <p>Reads and processes the search results into a MuData object.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultReader.read","title":"read","text":"<pre><code>read()\n</code></pre> <p>Reads and processes the search results into a MuData object.</p> <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: A MuData object containing the processed search results.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultSettings","title":"SearchResultSettings  <code>dataclass</code>","text":"<pre><code>SearchResultSettings(search_engine, quantification, label, acquisition, output_dir, feature_file, feature_level, quantification_file, quantification_level, config_file, feat_quant_merged, has_decoy=True)\n</code></pre> <p>Dataclass to store search result settings.</p> <p>Attributes:</p> Name Type Description <code>search_engine</code> <code>str</code> <p>Name of the search engine used (e.g., \"sage\", \"maxquant\").</p> <code>quantification</code> <code>str | None</code> <p>Name of the quantification tool used (e.g., \"sage\", \"maxquant\", or None).</p> <code>label</code> <code>str</code> <p>Labeling method used (e.g., \"tmt\", \"label_free\").</p> <code>output_dir</code> <code>Path</code> <p>Directory where the search results are stored.</p> <code>feature_file</code> <code>str</code> <p>Name of the feature file.</p> <code>feature_level</code> <code>str</code> <p>Level of the feature data (e.g., \"psm\", \"precursor\", \"peptide\", \"protein\").</p> <code>quantification_file</code> <code>str | None</code> <p>Name of the quantification file (if applicable).</p> <code>quantification_level</code> <code>str | None</code> <p>Level of the quantification data (e.g., \"psm\", \"precursor\", \"peptide\", \"protein\", or None).</p> <code>config_file</code> <code>str | None</code> <p>Name of the configuration file (if applicable).</p> <code>feat_quant_merged</code> <code>bool</code> <p>Indicates if feature and quantification are merged in a single file.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultSettings.config_path","title":"config_path  <code>property</code>","text":"<pre><code>config_path\n</code></pre> <p>Returns the full path to the configuration file if it exists, otherwise returns None.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultSettings.feature_path","title":"feature_path  <code>property</code>","text":"<pre><code>feature_path\n</code></pre> <p>Returns the full path to the feature file if it exists, otherwise returns None.</p>"},{"location":"reference/_read_write/_base_reader/#msmu._read_write._base_reader.SearchResultSettings.quantification_path","title":"quantification_path  <code>property</code>","text":"<pre><code>quantification_path\n</code></pre> <p>Returns the full path to the quantification file if it exists, otherwise returns None.</p>"},{"location":"reference/_read_write/_diann/","title":"<code>msmu._read_write._diann</code>","text":""},{"location":"reference/_read_write/_diann/#msmu._read_write._diann.DiannReader","title":"DiannReader","text":"<pre><code>DiannReader(search_dir)\n</code></pre> <p>               Bases: <code>SearchResultReader</code></p> <p>Reader for DIA-NN output files.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the DIA-NN output directory.</p> required"},{"location":"reference/_read_write/_fragpipe/","title":"<code>msmu._read_write._fragpipe</code>","text":""},{"location":"reference/_read_write/_maxquant/","title":"<code>msmu._read_write._maxquant</code>","text":""},{"location":"reference/_read_write/_maxquant/#msmu._read_write._maxquant.MaxQuantReader","title":"MaxQuantReader","text":"<pre><code>MaxQuantReader(search_dir)\n</code></pre> <p>               Bases: <code>SearchResultReader</code></p> <p>Reader for MaxQuant output files. Args:     maxquant_output_dir (str | Path): Path to the MaxQuant output directory.     label (Literal[\"tmt\", \"label_free\"]): Label for the MaxQuant output ('tmt' or 'label_free').</p>"},{"location":"reference/_read_write/_mdata_status/","title":"<code>msmu._read_write._mdata_status</code>","text":""},{"location":"reference/_read_write/_reader_registry/","title":"<code>msmu._read_write._reader_registry</code>","text":""},{"location":"reference/_read_write/_reader_registry/#msmu._read_write._reader_registry.read_diann","title":"read_diann  <code>module-attribute</code>","text":"<pre><code>read_diann = _ReadDiannFacade()\n</code></pre> <p>Alias for :class:<code>_ReadDiannFacade</code>.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the DIA-NN output directory.</p> required <p>Returns:</p> Type Description <code>_ReadDiannFacade</code> <p>md.MuData: A MuData object containing the DIA-NN data at precursor level</p> Usage <p>mdata_precursor = mm.read_diann(search_dir) mdata_protein_group = mm.read_diann.from_pg(search_dir)</p>"},{"location":"reference/_read_write/_reader_registry/#msmu._read_write._reader_registry.read_fragpipe","title":"read_fragpipe  <code>module-attribute</code>","text":"<pre><code>read_fragpipe = FragPipeFacade()\n</code></pre> <p>Alias for :class:<code>FragPipeFacade</code>.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the FragPipe output directory.</p> required <p>Returns:</p> Type Description <code>FragPipeFacade</code> <p>md.MuData: A MuData object containing the FragPipe data at precursor level</p> Usage <p>mdata_precursor = mm.read_fragpipe(search_dir) mdata_protein_group = mm.read_fragpipe.from_pg(search_dir)</p>"},{"location":"reference/_read_write/_reader_registry/#msmu._read_write._reader_registry.read_maxquant","title":"read_maxquant  <code>module-attribute</code>","text":"<pre><code>read_maxquant = _MaxQuantFacade()\n</code></pre> <p>Alias for :class:<code>_MaxQuantFacade</code>.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the MaxQuant output directory.</p> required <p>Returns:</p> Type Description <code>_MaxQuantFacade</code> <p>md.MuData: A MuData object containing the MaxQuant data at precursor level</p> Usage <p>mdata_precursor = mm.read_maxquant(search_dir) mdata_protein_group = mm.read_maxquant.from_pg(search_dir)</p>"},{"location":"reference/_read_write/_reader_registry/#msmu._read_write._reader_registry.read_h5mu","title":"read_h5mu","text":"<pre><code>read_h5mu(h5mu_file)\n</code></pre> <p>Reads an h5mu file (HDF5) and returns a MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>h5mu_file</code> <code>str | Path</code> <p>Path to the H5MU file.</p> required <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: A MuData object.</p>"},{"location":"reference/_read_write/_reader_registry/#msmu._read_write._reader_registry.read_sage","title":"read_sage","text":"<pre><code>read_sage(search_dir, label, _quantification=True)\n</code></pre> <p>Reads Sage output and returns a MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the Sage output directory.</p> required <code>label</code> <code>Literal['tmt', 'label_free']</code> <p>Label for the Sage output ('tmt' or 'label_free').</p> required <code>_quantification</code> <code>bool</code> <p>Whether to include quantification data. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: A MuData object containing the Sage data.</p>"},{"location":"reference/_read_write/_reader_utils/","title":"<code>msmu._read_write._reader_utils</code>","text":""},{"location":"reference/_read_write/_reader_utils/#msmu._read_write._reader_utils.add_modality","title":"add_modality","text":"<pre><code>add_modality(mdata, adata, mod_name, parent_mods)\n</code></pre> <p>Adds a new modality to a MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>Input MuData object.</p> required <code>adata</code> <code>AnnData</code> <p>AnnData object to add as a modality.</p> required <code>mod_name</code> <code>str</code> <p>Name of the new modality.</p> required <code>parent_mods</code> <code>list[str]</code> <p>List of parent modalities.</p> required <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: Updated MuData object with the new modality.</p>"},{"location":"reference/_read_write/_reader_utils/#msmu._read_write._reader_utils.merge_mudata","title":"merge_mudata","text":"<pre><code>merge_mudata(mdatas)\n</code></pre> <p>Merges multiple MuData objects into a single MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdatas</code> <code>dict[str, MuData]</code> <p>Dictionary of MuData objects to merge.</p> required <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: Merged MuData object.</p>"},{"location":"reference/_read_write/_reader_utils/#msmu._read_write._reader_utils.to_categorical","title":"to_categorical","text":"<pre><code>to_categorical(df)\n</code></pre> <p>Converts object-type columns in a DataFrame to categorical.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input DataFrame.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with object columns converted to categorical.</p>"},{"location":"reference/_read_write/_sage/","title":"<code>msmu._read_write._sage</code>","text":""},{"location":"reference/_read_write/_sage/#msmu._read_write._sage.LfqSageReader","title":"LfqSageReader","text":"<pre><code>LfqSageReader(search_dir, _quantification=True)\n</code></pre> <p>               Bases: <code>SageReader</code></p> <p>Reader for label-free Sage output files.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the Sage output directory.</p> required <code>_quantification</code> <code>bool</code> <p>Whether to include quantification data (lfq.tsv). Default is True.</p> <code>True</code>"},{"location":"reference/_read_write/_sage/#msmu._read_write._sage.SageReader","title":"SageReader","text":"<pre><code>SageReader(search_dir, label=None)\n</code></pre> <p>               Bases: <code>SearchResultReader</code></p> <p>Reader for Sage output files.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the Sage output directory.</p> required <code>label</code> <code>Literal['tmt', 'label_free'] | None</code> <p>Label for the Sage output ('tmt' or 'label_free').</p> <code>None</code>"},{"location":"reference/_read_write/_sage/#msmu._read_write._sage.TmtSageReader","title":"TmtSageReader","text":"<pre><code>TmtSageReader(search_dir)\n</code></pre> <p>               Bases: <code>SageReader</code></p> <p>Reader for TMT-labeled Sage output files.</p> <p>Parameters:</p> Name Type Description Default <code>search_dir</code> <code>str | Path</code> <p>Path to the Sage output directory.</p> required"},{"location":"reference/_read_write/label_info/","title":"<code>msmu._read_write.label_info</code>","text":""},{"location":"reference/_read_write/normalise_sage_columns_deprecated/","title":"<code>msmu._read_write.normalise_sage_columns_deprecated</code>","text":""},{"location":"reference/_read_write/protein_info_parser/","title":"<code>msmu._read_write.protein_info_parser</code>","text":""},{"location":"reference/_stats/","title":"_stats","text":""},{"location":"reference/_stats/target_decoy_q/","title":"<code>msmu._stats.target_decoy_q</code>","text":""},{"location":"reference/_stats/target_decoy_q/#msmu._stats.target_decoy_q.compute_fdr_q","title":"compute_fdr_q","text":"<pre><code>compute_fdr_q(target_decoy)\n</code></pre> <p>Compute FDR and q-values for the picked target-decoy pairs. Args:     picked_target_decoy (pd.DataFrame): DataFrame with 'score' and 'is_decoy' Returns:     pd.DataFrame: DataFrame with 'is_decoy' and 'q_value' columns.</p>"},{"location":"reference/_stats/target_decoy_q/#msmu._stats.target_decoy_q.concat_target_decoy","title":"concat_target_decoy","text":"<pre><code>concat_target_decoy(identification_df, decoy_df)\n</code></pre> <p>Concatenate target and decoy DataFrames with an 'is_decoy' column. Args:     identification_df (pd.DataFrame): DataFrame containing target identifications.     decoy_df (pd.DataFrame): DataFrame containing decoy identifications. Returns:     pd.DataFrame: Concatenated DataFrame with 'is_decoy' column.</p>"},{"location":"reference/_stats/target_decoy_q/#msmu._stats.target_decoy_q.estimate_q_values","title":"estimate_q_values","text":"<pre><code>estimate_q_values(identification_df, decoy_df)\n</code></pre> <p>Estimate q-values for target and decoy identifications using target-decoy competition.</p> <p>Parameters:</p> Name Type Description Default <code>identification_df</code> <code>DataFrame</code> <p>DataFrame containing target identifications with 'score' column.</p> required <code>decoy_df</code> <code>DataFrame</code> <p>DataFrame containing decoy identifications with 'score' column.</p> required <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>tuple[pd.DataFrame, pd.DataFrame]: Tuple of DataFrames (identification_with_q, decoy_with_q)</p>"},{"location":"reference/_stats/target_decoy_q/#msmu._stats.target_decoy_q.retrieve_target_decoy_with_q_values","title":"retrieve_target_decoy_with_q_values","text":"<pre><code>retrieve_target_decoy_with_q_values(identification_df, decoy_df, q_vals)\n</code></pre> <p>Retrieve target and decoy DataFrames with assigned q-values. Args:     identification_df (pd.DataFrame): DataFrame containing target identifications.     decoy_df (pd.DataFrame): DataFrame containing decoy identifications.     q_vals (pd.DataFrame): DataFrame with 'is_decoy' and 'q_value' columns. Returns:     tuple[pd.DataFrame, pd.DataFrame]: Tuple of DataFrames (identification_with_q, decoy_with_q)</p>"},{"location":"reference/_tools/","title":"_tools","text":""},{"location":"reference/_tools/_pca/","title":"<code>msmu._tools._pca</code>","text":""},{"location":"reference/_tools/_precursor_purity/","title":"<code>msmu._tools._precursor_purity</code>","text":""},{"location":"reference/_tools/_precursor_purity/#msmu._tools._precursor_purity.PrecursorPurityCalculator","title":"PrecursorPurityCalculator","text":"<pre><code>PrecursorPurityCalculator(tolerance=20, unit_ppm=True)\n</code></pre> <p>A class to calculate precursor isolation purity from mzML files or MuData objects. This class can be initialized with a tolerance value and whether to use ppm for the calculation. This class is a wrapper around the OpenMS PrecursorPurity class and provides methods to calculate. pyopenms: https://pyopenms.readthedocs.io/en/latest/py-modindex.html#module-pyopenms.PrecursorPurity</p> <p>Attributes:</p> Name Type Description <code>tolerance</code> <code>float</code> <p>Tolerance for precursor purity calculation.</p> <code>unit_ppm</code> <code>bool</code> <p>Whether to use ppm for tolerance.</p> <code>mzml</code> <code>Path | None</code> <p>Path to the mzML file.</p> <code>exp</code> <code>MSExperiment | None</code> <p>OpenMS MSExperiment object loaded from the mzML file.</p> <code>exp_src</code> <code>Path | None</code> <p>Source path of the loaded MSExperiment.</p> <code>exp_mtime</code> <code>float | None</code> <p>Last modified time of the mzML file.</p> <code>lock</code> <code>Lock</code> <p>Thread lock for thread-safe access to the MSExperiment.</p>"},{"location":"reference/_tools/_precursor_purity/#msmu._tools._precursor_purity.PrecursorPurityCalculator.from_mudata","title":"from_mudata  <code>classmethod</code>","text":"<pre><code>from_mudata(mdata, tolerance=20.0, unit_ppm=True)\n</code></pre> <p>Initialize PrecursorPurityCalculator from a MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing PSM data.</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for precursor purity calculation.</p> <code>20.0</code> <code>unit_ppm</code> <code>bool</code> <p>Whether to use ppm for tolerance.</p> <code>True</code>"},{"location":"reference/_tools/_precursor_purity/#msmu._tools._precursor_purity.PurityResult","title":"PurityResult","text":"<pre><code>PurityResult(purity, scan_num, filename)\n</code></pre>"},{"location":"reference/_tools/_precursor_purity/#msmu._tools._precursor_purity.PurityResult.to_df","title":"to_df","text":"<pre><code>to_df()\n</code></pre> <p>Convert the PurityResult to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing purity, scan_num, and filename.</p>"},{"location":"reference/_tools/_precursor_purity/#msmu._tools._precursor_purity.compute_precursor_purity","title":"compute_precursor_purity","text":"<pre><code>compute_precursor_purity(mzml_paths, tolerance=20.0, unit_ppm=True)\n</code></pre> <p>Calculate precursor isolation purity for all MS2 scans in the given mzML file.</p> <p>Parameters:</p> Name Type Description Default <code>mzml_paths</code> <code>str | Path | list</code> <p>Full path(s) to the mzML file.</p> required <code>tolerance</code> <code>float</code> <p>Tolerance for precursor purity calculation.</p> <code>20.0</code> <code>unit_ppm</code> <code>bool</code> <p>Whether to use ppm for tolerance.</p> <code>True</code> <p>Returns:</p> Type Description <code>PurityResult</code> <p>pd.DataFrame: DataFrame with scan numbers and their corresponding purity scores.</p>"},{"location":"reference/_tools/_umap/","title":"<code>msmu._tools._umap</code>","text":""},{"location":"reference/_tools/_umap/#msmu._tools._umap.umap","title":"umap","text":"<pre><code>umap(mdata, modality, n_comps=2, n_neighbors=None, metric='euclidean', init='random', min_dist=0.1, random_state=0)\n</code></pre> <p>Calculate UMAP embedding for a given modality in MuData object.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing the data.</p> required <code>modality</code> <code>str</code> <p>The modality to perform UMAP on.</p> required <code>n_comps</code> <code>int</code> <p>Number of UMAP components to compute. Default is 2.</p> <code>2</code> <code>n_neighbors</code> <code>int</code> <p>Number of neighbors to use. If None, set to number of samples - 1. Default is None.</p> <code>None</code> <code>metric</code> <code>str</code> <p>Metric to use for UMAP. Default is 'euclidean'.</p> <code>'euclidean'</code> <code>init</code> <code>str</code> <p>Initialization method for UMAP. Default is 'random'.</p> <code>'random'</code> <code>min_dist</code> <code>float</code> <p>Minimum distance parameter for UMAP. Default is 0.1.</p> <code>0.1</code> <code>random_state</code> <code>int | None</code> <p>Random state for reproducibility. Default is 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>MuData</code> <code>MuData</code> <p>Updated MuData object with UMAP results.</p>"},{"location":"reference/_tools/_dea/","title":"_dea","text":""},{"location":"reference/_tools/_dea/PermutationTest/","title":"<code>msmu._tools._dea.PermutationTest</code>","text":""},{"location":"reference/_tools/_dea/PermutationTest/#msmu._tools._dea.PermutationTest.Dea","title":"Dea","text":"<pre><code>Dea()\n</code></pre> <p>Class to perform Differential Expression Analysis (DEA) using permutation tests. This class is used to compare two groups of data (control and experimental) and calculate statistics such as median differences, fold changes, and p-values.</p>"},{"location":"reference/_tools/_dea/PermutationTest/#msmu._tools._dea.PermutationTest.Dea.de_available","title":"de_available  <code>property</code> <code>writable</code>","text":"<pre><code>de_available\n</code></pre> <p>Check if DEA is available based on the number of samples in control and experimental groups. Returns True if DEA is available, False otherwise.</p>"},{"location":"reference/_tools/_dea/PermutationTest/#msmu._tools._dea.PermutationTest.PermutationTest","title":"PermutationTest","text":"<pre><code>PermutationTest(ctrl_arr, expr_arr, n_resamples, force_resample, fdr)\n</code></pre> <p>               Bases: <code>Dea</code></p> <p>Class to perform permutation tests on two groups of data (control and experimental). Parameters</p> <p>ctrl_arr : np.ndarray     Array of control group data (n_features x n_samples_ctrl). expr_arr : np.ndarray     Array of experimental group data (n_features x n_samples_expr). n_resamples : int     Number of resamples for the permutation test. force_resample : bool     If True, forces resampling even if the number of resamples exceeds the number of combinations.</p>"},{"location":"reference/_tools/_dea/PermutationTest/#msmu._tools._dea.PermutationTest.PermutationTest--attributes","title":"Attributes","text":"<p>ctrl_arr : np.ndarray     Control group data. expr_arr : np.ndarray     Experimental group data. possible_combination_count : int     Total number of possible combinations of control and experimental samples. permutation_method : str     Method used for permutation (exact or randomised). n_resamples : int     Number of resamples for the permutation test. force_resample : bool     If True, forces resampling even if the number of resamples exceeds the number of combinations.</p>"},{"location":"reference/_tools/_dea/PermutationTest/#msmu._tools._dea.PermutationTest.PermutationTestResult","title":"PermutationTestResult  <code>dataclass</code>","text":"<pre><code>PermutationTestResult(permutation_method, statistic, ctrl, expr, features, median_ctrl, median_expr, pct_ctrl, pct_expr, log2fc, p_value, q_value, fc_pct_1, fc_pct_5)\n</code></pre> <p>Data class to hold the results of a permutation test. Attributes: - permutation_method: Method used for permutation (exact or randomised). - statistic: The statistic used for the test (e.g., t-test, wilcoxon, median_diff). - features: Array of feature names (e.g., proteins, ptm sites). - median_ctrl: Median values for control group. - median_expr: Median values for experimental group. - pct_ctrl: Percentage of non-missing values in control group. - pct_expr: Percentage of non-missing values in experimental group. - log2fc: Log2 fold change values. - p_value: P-values for the permutation test. - fc_pct_1: log2fc cutoff at 1%. - fc_pct_5: log2fc cutoff at 5%.</p>"},{"location":"reference/_tools/_dea/StatTest/","title":"<code>msmu._tools._dea.StatTest</code>","text":""},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.NullDistribution","title":"NullDistribution  <code>dataclass</code>","text":"<pre><code>NullDistribution(method, null_distribution)\n</code></pre> <p>Data class to store null distribution from permutation tests. Attributes:     method (str): The statistical method used.     null_distribution (np.ndarray): 2D array of null test statistics (shape: [n_permutations, n_features]).</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.NullDistribution.add_permutation_result","title":"add_permutation_result","text":"<pre><code>add_permutation_result(other)\n</code></pre> <p>Add (stack) a new permutation result to the null distribution. Parameters: other : StatResult     A StatResult object containing the statistic from a new permutation. Returns: NullDistribution     A new NullDistribution object with the updated null distribution.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection","title":"PvalueCorrection","text":"<p>Class for multiple testing correction methods. Methods:     bh : Benjamini-Hochberg FDR correction.     storey : Storey's q-value estimation with pi0 estimation.     empirical : Permutation-based empirical FDR estimation.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.bh","title":"bh  <code>staticmethod</code>","text":"<pre><code>bh(pvals)\n</code></pre> <p>Benjamini-Hochberg FDR correction with NaN handling. Parameters</p> <p>pvals : array-like     Array of p-values (can include NaN). Returns</p> <p>qvals : np.ndarray     Array of q-values (NaN-filled where p was NaN).</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.empirical","title":"empirical  <code>staticmethod</code>","text":"<pre><code>empirical(stat_obs, null_dist, two_sided=True)\n</code></pre> <p>Permutation-based empirical FDR estimation using: - Storey's method for pi0 (default) - or permutation-statistic-based method (equation 8)</p> <p>References: - https://academic.oup.com/bioinformatics/article/21/23/4280/194680 - https://www.pnas.org/doi/epdf/10.1073/pnas.1530509100</p> <p>E[FDR] = pi0 * E[FP] / E[TP] E[FP] = #(FP &gt;= s) / B (# permutation) E[TP] = #(TP &gt;= s)</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.estimate_pi0_null","title":"estimate_pi0_null  <code>staticmethod</code>","text":"<pre><code>estimate_pi0_null(stat_valid, null_matrix_valid, percentile=95)\n</code></pre> <p>Estimate pi0 (proportion of true null hypotheses) using permutation-based statistic exceedance method. https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2013.00179/full Based on Equation (8): compares observed and null test statistic exceedances at a given threshold. pi0 = (1 - S/m) / (1 - S_star/m)</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.estimate_pi0_null--parameters","title":"Parameters","text":"<p>stat_valid : np.ndarray     1D array of observed test statistics (NaN-excluded). null_matrix_valid : np.ndarray     2D array of null test statistics (shape: [n_permutations, m_valid]),     aligned with stat_valid (i.e., same features, same filtering). percentile : float, default=95     Percentile value used to define the threshold for exceedance comparison.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.estimate_pi0_null--returns","title":"Returns","text":"<p>pi0 : float     Estimated proportion of true null hypotheses (clipped to [0, 1]).</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.estimate_pi0_storey","title":"estimate_pi0_storey  <code>staticmethod</code>","text":"<pre><code>estimate_pi0_storey(p_values, lambdas=np.linspace(0.5, 0.95, 10))\n</code></pre> <p>Storey's estimator of pi0 (proportion of true nulls) from observed p-values. https://www.frontiersin.org/journals/genetics/articles/10.3389/fgene.2013.00179/full Based on Equation (7) pi0 = #( pval &gt; lamda ) / ( 1 - lambda ) * m</p> <p>Parameters: - p_values: array of p-values (one per feature) - lambdas: array of lambda thresholds (typically 0.5 to 0.95)</p> <p>Returns: - pi0: estimated pi0 value - pi0_by_lambda: array of intermediate pi0 estimates</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.storey","title":"storey  <code>staticmethod</code>","text":"<pre><code>storey(p_values, lambda_=0.5, alpha=0.05, return_mask=False)\n</code></pre> <p>Storey (2002) q-value estimation with pi0 estimation.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.storey--parameters","title":"Parameters","text":"<p>p_values : array-like     Array of p-values (can include NaN). lambda_ : float     Threshold for estimating pi0 (0 &lt; lambda &lt; 1). Default = 0.5. alpha : float     FDR threshold for significance mask (only if return_mask=True). return_mask : bool     If True, also returns Boolean significance mask.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.PvalueCorrection.storey--returns","title":"Returns","text":"<p>q_values : np.ndarray     Array of q-values (NaN-filled where p was NaN). rejected : Optional[np.ndarray]     Boolean array indicating which features are significant under FDR &lt; alpha.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatResult","title":"StatResult  <code>dataclass</code>","text":"<pre><code>StatResult(stat_method, statistic, p_value)\n</code></pre> <p>Data class to store statistical test results. Attributes:     stat_method (str): The statistical method used.     statistic (np.ndarray): Array of test statistics.     p_value (np.ndarray): Array of p-values.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest","title":"StatTest","text":"<p>Class for performing statistical tests between two groups of samples. Attributes:     method (str): The statistical method to use ('welch', 'student', 'wilcoxon', 'med_diff').</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.calc_permutation_pvalue","title":"calc_permutation_pvalue  <code>staticmethod</code>","text":"<pre><code>calc_permutation_pvalue(stat_obs, null_dist)\n</code></pre> <p>Permutation-based empirical p-value calculation (two-sided). Parameters</p> <p>stat_obs : np.ndarray     1D array of observed test statistics (one per feature). null_dist : np.ndarray     2D array of null test statistics (shape: [n_permutations, n_features]). Returns</p> <p>pvals : np.ndarray     Array of empirical p-values (NaN-filled where stat_obs was NaN).</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.median_diff","title":"median_diff  <code>staticmethod</code>","text":"<pre><code>median_diff(ctrl, expr)\n</code></pre> <p>Median difference (expr - ctrl) with NaN handling. Parameters:</p> <p>ctrl : array-like (n_samples_ctrl x n_features) expr : array-like (n_samples_expr x n_features) Returns:</p> <p>med_diff : np.ndarray     Median differences for each feature.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.student","title":"student  <code>staticmethod</code>","text":"<pre><code>student(ctrl, expr)\n</code></pre> <p>Student's t-test with NaN handling (equal variance assumed). Not using scipy because of time complexity.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.student--parameters","title":"Parameters:","text":"<p>ctrl : array-like (n_samples_ctrl x n_features) expr : array-like (n_samples_expr x n_features)</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.student--returns","title":"Returns:","text":"<p>t_val : np.ndarray     T-statistics for each feature. pval : np.ndarray     Two-tailed p-values.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.welch","title":"welch  <code>staticmethod</code>","text":"<pre><code>welch(ctrl, expr)\n</code></pre> <p>Welch's t-test with NaN handling (manual implementation). Not using scipy because of time complexity.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.welch--parameters","title":"Parameters:","text":"<p>ctrl : array-like (n_samples_ctrl x n_features) expr : array-like (n_samples_expr x n_features)</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.welch--returns","title":"Returns:","text":"<p>t_val : np.ndarray     T-statistics for each feature. pval : np.ndarray     Two-tailed p-values.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTest.wilcoxon_rank_sum","title":"wilcoxon_rank_sum  <code>staticmethod</code>","text":"<pre><code>wilcoxon_rank_sum(ctrl, expr)\n</code></pre> <p>Wilcoxon rank-sum test (Mann-Whitney U test) with NaN handling. Uses scipy's ranksums function which handles NaNs internally. Parameters:</p> <p>ctrl : array-like (n_samples_ctrl x n_features) expr : array-like (n_samples_expr x n_features) Returns:</p> <p>stat : np.ndarray     Test statistics for each feature. pval : np.ndarray     Two-tailed p-values.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTestReusult","title":"StatTestReusult  <code>dataclass</code>","text":"<pre><code>StatTestReusult(statistic, ctrl, expr=None, features=None, median_ctrl=None, median_expr=None, pct_ctrl=None, pct_expr=None, log2_fc=None, p_value=None, q_value=None)\n</code></pre> <p>Data class to store and convert statistical test results to a DataFrame. Attributes:     stat_method (str): The statistical method used.     statistic (str): The statistic computed.     ctrl (str | None): Control group label.     expr (str | None): Experimental group label.     features (pd.Index | np.ndarray | None): Feature identifiers.     median_ctrl (np.ndarray | None): Median values for control group.     median_expr (np.ndarray | None): Median values for experimental group.     pct_ctrl (np.ndarray | None): Percentage of non-missing values in control group.     pct_expr (np.ndarray | None): Percentage of non-missing values in experimental group.     log2_fc (np.ndarray | None): Log2 fold changes between groups.     p_value (np.ndarray | None): P-values from statistical tests.     q_value (np.ndarray | None): Adjusted q-values for multiple testing.</p>"},{"location":"reference/_tools/_dea/StatTest/#msmu._tools._dea.StatTest.StatTestReusult.to_df","title":"to_df","text":"<pre><code>to_df()\n</code></pre> <p>Convert the statistical test results to a pandas DataFrame. Returns:     pd.DataFrame: DataFrame containing the statistical test results.</p>"},{"location":"reference/_tools/_dea/_dea/","title":"<code>msmu._tools._dea._dea</code>","text":""},{"location":"reference/_tools/_dea/_dea/#msmu._tools._dea._dea.permutation_test","title":"permutation_test","text":"<pre><code>permutation_test(mdata, category, control, expr=None, modality='protein', n_resamples=1000, n_jobs=1, statistic='welch', force_resample=False, fdr='empirical')\n</code></pre> <p>Perform a permutation test on the given MuData object. Parameters</p> <p>mdata : md.MuData     The MuData object containing the data. modality : str     The modality to perform the test on. Default is 'protein' category : str     The category column in the mdata.obs. control : str     The control group label. expr : str | None     The experimental group label. If None, all other groups are considered experimental. Default is None. n_resamples : int     The number of resamples for the permutation test. Default is 1000. n_jobs : int     The number of parallel jobs to run. statistic : str     The statistical test to use. Options are 'welch', 'student', 'wilcoxon', or 'median_diff'. Default is 'welch'. fdr: str | bool     The FDR control method to use. Options are 'empirical', 'bh', 'storey'. Default is 'empirical'. force_resample : bool     If True, forces resampling even if the number of permutations exceeds the possible combinations. Default is False. Returns</p> <p>PermutationTestResult     The result of the permutation test. Raises</p> <p>ValueError     If the statistic is not one of the supported types.</p>"},{"location":"reference/_utils/","title":"_utils","text":""},{"location":"reference/_utils/fasta/","title":"<code>msmu._utils.fasta</code>","text":""},{"location":"reference/_utils/fasta/#msmu._utils.fasta.map_fasta","title":"map_fasta","text":"<pre><code>map_fasta(mdata, modality, categories=['Protein ID', 'Gene', 'Description', 'Organism'])\n</code></pre> <p>Map protein groups to gene names using a FASTA metadata DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object containing the modality to map.</p> required <code>modality</code> <code>str</code> <p>The modality in the MuData object to map.</p> required <code>categories</code> <code>list[str]</code> <p>List of categories to map from fasta metadata.</p> <code>['Protein ID', 'Gene', 'Description', 'Organism']</code> <p>Returns:</p> Type Description <code>MuData</code> <p>md.MuData: MuData object with updated modality var.</p>"},{"location":"reference/_utils/peptide/","title":"<code>msmu._utils.peptide</code>","text":"<p>Peptide-related helper functions shared across readers.</p> <p>These utilities stay free of reader-specific dependencies so they can be reused wherever peptide string processing or basic precursor calculations are needed.</p>"},{"location":"reference/_utils/protein/","title":"<code>msmu._utils.protein</code>","text":""},{"location":"reference/_utils/protein/#msmu._utils.protein.select_repr_protein","title":"select_repr_protein","text":"<pre><code>select_repr_protein(mdata, modality)\n</code></pre> <p>Select canonical protein from protein list based on priority. canonical &gt; swissprot &gt; trembl &gt; contam</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object with protein groups inferred</p> required <code>modality</code> <code>str</code> <p>Modality name for protein data</p> required <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>MuData object with representative proteins selected</p>"},{"location":"reference/_utils/protein/#msmu._utils.protein.select_representative","title":"select_representative","text":"<pre><code>select_representative(protein_group, protein_info)\n</code></pre> <p>Select canonical protein from protein list based on priority. canonical &gt; swissprot &gt; trembl &gt; contam</p> <p>Parameters:</p> Name Type Description Default <code>protein_list</code> <code>list[str]</code> <p>list of proteins (uniprot entry)</p> required <code>protein_info</code> <code>DataFrame</code> <p>DataFrame of protein info from mdata.uns['protein_info']</p> required <p>Returns:</p> Name Type Description <code>protein_group</code> <code>str</code> <p>canonical protein group</p>"},{"location":"reference/_utils/subset/","title":"<code>msmu._utils.subset</code>","text":""},{"location":"reference/_utils/subset/#msmu._utils.subset.split_tmt","title":"split_tmt","text":"<pre><code>split_tmt(mdata, map)\n</code></pre> <p>Split TMT channels in a MuData object into separate modalities based on a mapping.</p>"},{"location":"reference/_utils/subset/#msmu._utils.subset.split_tmt--parameters","title":"Parameters","text":"<p>mdata : MuData     The MuData object containing TMT data. map : dict[str, str] | pd.Series | pd.DataFrame     A mapping of filenames to set names. If a DataFrame is provided, it should have two columns: the first for filenames and the second for set names.</p>"},{"location":"reference/_utils/subset/#msmu._utils.subset.split_tmt--returns","title":"Returns","text":"<p>MuData     The modified MuData object with TMT channels split into separate modalities.</p>"},{"location":"reference/_utils/subset/#msmu._utils.subset.subset","title":"subset","text":"<pre><code>subset(mdata, modality, cond_var=None, cond_obs=None)\n</code></pre> <p>Subset MuData object based on condition.</p> <p>Parameters:</p> Name Type Description Default <code>mdata</code> <code>MuData</code> <p>MuData object to subset.</p> required <code>modality</code> <code>str</code> <p>Modality to subset.</p> required <code>cond_var</code> <code>str</code> <p>Condition to subset variables.</p> <code>None</code> <code>cond_obs</code> <code>str</code> <p>Condition to subset observations.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>mdata</code> <code>MuData</code> <p>Subsetted MuData object.</p>"},{"location":"reference/_utils/utils/","title":"<code>msmu._utils.utils</code>","text":""},{"location":"reference/_utils/utils/#msmu._utils.utils.get_modality_dict","title":"get_modality_dict","text":"<pre><code>get_modality_dict(mdata, level=None, modality=None)\n</code></pre> <p>Get modality data from MuData object</p>"},{"location":"reference/_utils/utils/#msmu._utils.utils.rename_obs","title":"rename_obs","text":"<pre><code>rename_obs(mdata, map)\n</code></pre> <p>Rename an observation (obs) column in the MuData object.</p>"},{"location":"reference/_utils/utils/#msmu._utils.utils.rename_obs--parameters","title":"Parameters","text":"<p>mdata : md.MuData     The MuData object containing the observation to rename. obs_name : str     The current name of the observation to rename. new_obs_name : str     The new name for the observation.</p>"},{"location":"reference/_utils/utils/#msmu._utils.utils.rename_obs--returns","title":"Returns","text":"<p>md.MuData     The modified MuData object with the renamed observation.</p>"},{"location":"tutorials/dia/","title":"DIA","text":""},{"location":"tutorials/lfq/","title":"Label-free Quantification","text":""},{"location":"tutorials/quick_start/","title":"Quick Start","text":"In\u00a0[\u00a0]: Copied! <pre>import msmu as mm\n</pre> import msmu as mm In\u00a0[\u00a0]: Copied! <pre>mdata = mm.read_sage(\"sage/output/dir\", label=\"tmt\")\n</pre> mdata = mm.read_sage(\"sage/output/dir\", label=\"tmt\")"},{"location":"tutorials/quick_start/#quick-start","title":"Quick Start\u00b6","text":""},{"location":"tutorials/quick_start/#load-msmu","title":"Load msmu\u00b6","text":""},{"location":"tutorials/quick_start/#read-search-output","title":"Read Search Output\u00b6","text":""},{"location":"tutorials/tmt/","title":"TMT","text":""}]}