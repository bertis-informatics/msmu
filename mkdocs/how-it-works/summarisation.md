# Summarisation (Aggregation)

## Overview

The term `Summarisation` refers to aggregating identification features and quantitative values as data move from one level to the next (e.g., PSM/precursor â†’ peptide â†’ protein).

Summarisation functions are provided as `to_*` methods, such as `to_peptide`, `to_protein`, and `to_ptm`.

## `to_peptide()`

`to_peptide()` function takes:
    - `mudata` containing `evidence` level modality
and returns
    - `mudata` with `peptide` level modality

This step aggregates features and quantification value by `peptide` (modified peptide).
Peptide-level `PEP` is calculated with `best PEP` method by default and peptide-level q-values are computed using a conservative approach when decoy information is available..

For quantification aggregation, the default method is `median`, and an optional `top_n` argument can be used to restrict aggregation to the `top N` features within each peptide. Feature ranking is based on `total_intensity` unless specified otherwise..

In TMT studies, features with low isolation purity may be excluded prior to quantification aggregation to avoid mixing reporter ion signals. Isolation purity should be computed with `mm.pp.compute_precursor_isolation_purity()` before calling `to_peptide()`. A `purity_threshold` (commonly `0.7`) can be applied during aggregation.

Note that filtering by `top_n` or `purity_threshold` affects quantification aggregation only and does not modify identification-level summarisation.

```python
mdata = mm.pp.to_peptide(
    mdata,
    score_method="best_pep",        # default
    agg_method="median",            # default
    purity_threshold=0.7            # for tmt data
    top_n=None,                     # default
    rank_method="total_intensity",  # default
    )
```


## `to_protein()`

`to_protein()` function takes:
    - `mudata` containing `peptide` modality with inferred `protein_group` and `peptide_type`
and returns:
    - `mudata` with `protein` level modality

Protein-level summarisation requires the `protein_group` and `peptide_type` columns, which are generated by mm.pp.infer_protein() from peptide-level data.
Details are provided in the [Protein Inference]() section. Briefly:
- `protein_group` contains the inferred protein groups for each peptide.
- `peptide_type` indicates whether a peptide is "unique" or "shared".

Only "unique" peptides are used for protein-group summarisation; "shared" peptides are excluded.

As in peptide-level aggregation, protein-group level `PEP` and `q-value` are computed when possible.

The default settings use `top_n=3` with ranking by `total_intensity`, so only the top three peptides per protein group contribute to quantification.


```python
# Infer protein-group from mdata (containing peptide modality)
mdata = mm.pp.infer_protein(mdata)

# Summarise peptides to protein-group
mdata = mm.pp.to_protein(
    mdata,
    score_method="best_pep",        # default
    agg_method="median",            # default
    top_n=3,                        # default
    rank_method="total_intensity",  # default
    )
```


## `to_ptm()`

To summarise modified peptide into post-translation modification (PTM) sites, `to_ptm()` uses the subset of peptides that contain the specified modification and then performs several steps to assign PTM positions at the protein level.

Internally, the function performs:
        1. Filtering data with only modified peptides with modi_identifier
        2. Extracting modified sites from peptide
        3. Assigning peptide-level site labels
        4. Exploding peptides to single proteins for per-protein site labeling
        5. Mapping the site to the corresponding position in each protein
        6. Merging single-protein results back into protein groups
        7. Grouping by modified peptide and peptide-site combination
        8. Merging site metadata with peptide-level quantification

`to_ptm()` function takes:
    - `mudata` containing `peptide` modality and attached fasta
and returns:
    - `mudata` with `ptm_site` level modality

A FASTA file is required because PTM sites must be mapped to protein-sequence coordinates. FASTA can be attached using `mm.utils.attach_fasta()`.

The argument `modi_name` determines the modality name (e.g., "phospho" â†’ "phospho_site"), and the `modification` string is used to identify modified peptides.

`agg_method` can be selected among methods as described in other summarisation functions.


```python
mdata = mm.utils.attach_fasta("fasta/file/path.fasta")

mdata = mm.pp.to_ptm(
    mdata,
    modi_name="phospho",
    modification="[+79.9663]",
    agg_method="median",        # default
    top_n=None                  # default
    )
```